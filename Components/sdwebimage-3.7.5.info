{"Name":"SDWebImage for Xamarin.iOS","Id":2485,"Alias":"sdwebimage","Description":"Adds methods to `UIImageView` supporting asynchronous web image loading:\n\n```csharp\nusing SDWebImage;\n...\n\nconst string CellIdentifier = \"Cell\";\n\npublic override UITableViewCell GetCell (UITableView tableView, NSIndexPath indexPath)\n{\n\tUITableViewCell cell = tableView.DequeueReusableCell (CellIdentifier) ??\n\t\tnew UITableViewCell (UITableViewCellStyle.Default, CellIdentifier);\n\t\n\t// Use the SetImage extension method to load the web image:\n\tcell.ImageView.SetImage (\n\t\turl: new NSUrl (\"http://db.tt/ayAqtbFy\"), \n\t\tplaceholder: UIImage.FromBundle (\"placeholder.png\")\n\t);\n\n\treturn cell;\n}\n```\n\nIt provides:\n\n* `UIImageView` and `UIButton` extension methods adding web image loading and cache management.\n* An asynchronous image downloader\n* An asynchronous memory + disk image caching with automatic cache expiration handling\n* Animated GIF support\n* WebP format support\n* A background image decompression\n* A guarantee that the same URL won\u0027t be downloaded several times\n* A guarantee that bogus URLs won\u0027t be retried again and again\n* A guarantee that main thread will never be blocked\n* Performances!\n* Use GCD and ARC\n* Arm64 support\n\n","Version":"3.7.5","Summary":"Extensions for UIImageView allowing you to asynchronously load web images.","QuickStart":"Adds methods to `UIImageView` supporting asynchronous web image loading:\n\n```csharp\nusing SDWebImage;\n...\n\nconst string CellIdentifier = \"Cell\";\n\npublic override UITableViewCell GetCell (UITableView tableView, NSIndexPath indexPath)\n{\n\tUITableViewCell cell = tableView.DequeueReusableCell (CellIdentifier) ??\n\t\tnew UITableViewCell (UITableViewCellStyle.Default, CellIdentifier);\n\t\n\t// Use the SetImage extension method to load the web image:\n\tcell.ImageView.SetImage (\n\t\turl: new NSUrl (\"http://db.tt/ayAqtbFy\"), \n\t\tplaceholder: UIImage.FromBundle (\"placeholder.png\")\n\t);\n\n\treturn cell;\n}\n```\n\nIt provides:\n\n* `UIImageView` and `UIButton` extension methods adding web image loading and cache management.\n* An asynchronous image downloader\n* An asynchronous memory + disk image caching with automatic cache expiration handling\n* Animated GIF support\n* WebP format support\n* A background image decompression\n* A guarantee that the same URL won\u0027t be downloaded several times\n* A guarantee that bogus URLs won\u0027t be retried again and again\n* A guarantee that main thread will never be blocked\n* Performances!\n* Use GCD and ARC\n* Arm64 support\n\n## iOS 9 Support\n\nSince iOS 9.0, Apple introduced a new security feature called App Transport Security.\nApp Transport Security (ATS) enforces best practices in the secure connections between an app and \nits back end. ATS prevents accidental disclosure, provides secure default behavior, and is easy \nto adopt; it is also on by default in iOS 9 and OS X v10.11. You should adopt ATS as soon as \npossible, regardless of whether you’re creating a new app or updating an existing one.\n\nIf you’re developing a new app, you should use HTTPS exclusively. If you have an existing app, \nyou should use HTTPS as much as you can right now, and create a plan for migrating the rest of \nyour app as soon as possible. In addition, your communication through higher-level APIs needs \nto be encrypted using TLS version 1.2 with forward secrecy. \n\nIf you try to make a connection that doesn\u0027t follow this requirement, an error is thrown. \nIf your app needs to make a request to an insecure domain, you have to specify this domain \nin your app\u0027s `Info.plist` file. \n\nFor example, if you are loading images from `http://example.org`, you will need to add that domain\nin the `Info.plist` file:\n\n    \u003ckey\u003eNSAppTransportSecurity\u003c/key\u003e\n\t\u003cdict\u003e\n        \u003ckey\u003eNSExceptionDomains\u003c/key\u003e\n\t\t\u003cdict\u003e\n\t\t    \u003ckey\u003eexample.org\u003c/key\u003e\n\t\t\t\u003cdict\u003e\n\t\t\t    \u003ckey\u003eNSIncludesSubdomains\u003c/key\u003e \u003cfalse/\u003e\n\t\t\t    \u003ckey\u003eNSTemporaryExceptionAllowsInsecureHTTPLoads\u003c/key\u003e \u003ctrue/\u003e\n\t\t\t\u003c/dict\u003e\n\t\t\u003c/dict\u003e\n\t\u003c/dict\u003e\n\nHowever, in the case where you need to access arbitrary domains, you can allow all requests \nto go through. However, this is not advised if using HTTPS is possible:\n\n    \u003ckey\u003eNSAppTransportSecurity\u003c/key\u003e  \n    \u003cdict\u003e\n        \u003ckey\u003eNSAllowsArbitraryLoads\u003c/key\u003e \u003ctrue/\u003e \n    \u003c/dict\u003e\n\n\n## Callbacks\n\nWith callbacks, you can be notified about the image download progress\nand whenever the image retrieval has completed:\n\n```csharp\ncell.ImageView.SetImage (\n\turl: new NSUrl (\"http://db.tt/ayAqtbFy\"), \n\tplaceholder: UIImage.FromBundle (\"placeholder.png\"),\n\tcompletedHandler: (image, error, cacheType) =\u003e {\n\t\t// Handle download completed...\n\t}\n);\n```\n\nCallbacks are not called if the request is canceled.\n\n## Using SDWebImageManager Independently\n\nThe SDWebImageManager is the class behind the UIImageView extension\nmethods. It owns the asynchronous downloader and the image cache.  You\ncan reuse this class directly for cached web image downloading in other\ncontexts.\n\n```csharp\nSDWebImageManager.SharedManager.Download (\n\turl: new NSUrl (\"http://db.tt/ayAqtbFy\"), \n\toptions: SDWebImageOptions.CacheMemoryOnly,\n\tprogressHandler: (recievedSize, expectedSize) =\u003e {\n\t\t// Track progress...\n\t},\n\tcompletedHandler: (image, error, cacheType, finished) =\u003e {\n\t\tif (image != null) {\n\t\t\t// do something with the image\n\t\t}\n\t}\n);\n```\n\n## Using SDWebImageDownloader Independently\n\nIt\u0027s also possible to use the asynchronous image downloader independently:\n\n```csharp\nSDWebImageDownloader.SharedDownloader.DownloadImage (\n\turl: new NSUrl (\"http://db.tt/ayAqtbFy\"),\n\toptions: SDWebImageDownloaderOptions.LowPriority,\n\tprogressHandler: (receivedSize, expectedSize) =\u003e {\n\t\t// Track progress...\n\t},\n\tcompletedHandler: (image, data, error, finished) =\u003e {\n\t\tif (image != null \u0026\u0026 finished) {\n\t\t\t// do something with the image\n\t\t}\n\t}\n);\n```\n\n## Using SDImageCache Independently\n\nYou may also use the image cache independently. SDImageCache maintains a\nmemory cache and an optional disk cache. Disk writes are performed\nasynchronously as well.\n\nThe SDImageCache class provides a singleton instance for convenience but\nyou can create your own instance if you want to create Independent\ncaches.\n\n```csharp\nvar myCache = new SDImageCache (\"MyUniqueCacheKey\");\n\nmyCache.QueryDiskCache (\"UniqueImageKey\", image =\u003e {\n\t// If image is not null, image was found\n\tif (image != null) {\n\t\t// Do something with the image\n\t}\n });\n```\n\nBy default SDImageCache will lookup the disk cache if an image can\u0027t be\nfound in the memory cache. You can prevent this from happening by\ncalling the alternative method `ImageFromMemoryCache`.\n\nTo store an image into the cache, you use the `StoreImage` method:\n\n```csharp\nSDImageCache.SharedImageCache.StoreImage (image: myImage, key: \"myKey\");\n```\n\nBy default, the image will be stored in memory cache as well as on disk\ncache. If you want only the memory cache use:\n\n\n```csharp\nSDImageCache.SharedImageCache.StoreImage (image: myImage, key: \"myKey\", toDisk: false);\n```\n\n## Using cache key filter\n\nSometimes, you may not want to use image URLs as cache keys because part\nof the URL is unstable.  SDWebImageManager provides a way to set a cache\nkey filter that maps NSUrls to cache key strings.\n\nThe following example sets a filter in the application delegate that\nremoves query parameters from the URL before querying the cache:\nkey:\n\n```csharp\nusing SDWebImage;\n...\n\npublic override bool FinishedLaunching (UIApplication app, NSDictionary options)\n{\n\tSDWebImageManager.SharedManager.SetCacheKeyFilter (url =\u003e {\n\t\tvar stableUrl = new NSUrl (scheme: url.Scheme, host: url.Host, path: url.Path);  \n\t\treturn stableUrl.AbsoluteString;\n\t});\n\t...\n}\n```\n\n## Handle image refresh\n\n`SDWebImage` does very aggressive caching by default; it ignores any\ncaching control headers returned by the HTTP server, and caches images\nwith no time restrictions. This implies that your images change only if\ntheir URLs change.\n\nIf you don\u0027t control the image server, you may not be able\nto change the URL when an image changes--this is the case with\nFacebook profile URLs, for example. In this case, you may use the\n`SDWebImageOptions.RefreshCached` flag, which causes the cache to\nrespect HTTP caching control headers:\n\n```csharp\nvar imageView = new UIImageView ();\nimageView.SetImage (\n\turl: new NSUrl (\"http://db.tt/ayAqtbFy\"), \n\tplaceholder: UIImage.FromBundle (\"yourPlaceholder.png\"),\n\toptions: SDWebImageOptions.RefreshCached\n);\n```\n","Hash":"329327f569427cfc2a897b5df97a67fc","TargetPlatforms":["ios","ios-unified"],"TrialHash":null}